\documentclass[a4paper]{article}
%\VignetteIndexEntry{coordinates}
\newcommand{\grid}{{\bf grid}}
\newcommand{\gridSVG}{{\sf gridSVG}}
\newcommand{\R}{{\sf R}}
\newcommand{\JS}{{\sf JavaScript}}
\newcommand{\SVG}{{\sf SVG}}
\newcommand{\code}[1]{{\tt #1}}
\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}

\usepackage{hyperref}

\title{Working with the gridSVG Coordinate System}
\author{Simon Potter}
\begin{document}

\maketitle

\section*{Introduction}

When exporting \grid{} graphics as \SVG{}, all information about the
coordinate system used by \grid{} is lost from the image as everything
is turned into pixels. This document describes how \gridSVG{} exports
additional information during this process to retain the coordinate
system.

To demonstrate this, we will show how to add points to an exported
plot, both from within \R{} and also, less permanently, within a \JS{}
and \SVG{} capable web browser.

Firstly, consider the following code which is a simple plot containing
two items of interest. Firstly, a viewport is created which has scales
defined for each of its axes. Secondly, points are added to the plot
using native units. We then write this out to \SVG{} in a file called
\code{"pointsPlot.svg"} which can be viewed in a web browser.

<<>>=
library(gridSVG)
@

<<pointsPlot, fig=TRUE, include=FALSE>>=
panelvp <- plotViewport(xscale = c(0, 20),
                        yscale = c(0, 20),
                        name = "panelvp")
pushViewport(panelvp)
grid.xaxis()
grid.yaxis()
grid.points(x = runif(10, 5, 15),
            y = runif(10, 5, 15),
            pch = 16,
            name = "datapoints")
popViewport()

gridToSVG("pointsPlot.svg")
@

The challenge is to now modify this plot so that we can add extra
information, such as new data points. As the \SVG{} file was exported,
all of the locations on the plot were transformed into pixels. This
means that in our \SVG{} file, none of the axis scales exist, and the
locations of points are no longer native coordinates, but absolutely
positioned pixels.

Recent changes in \gridSVG{} have enabled us to retain this
information by exporting viewport metadata in the form of
\textsf{JSON}. This enables us to be able to retain viewport locations
and scales so that we can now transform pixel locations to native
coordinates, and vice versa.

The following fragment shows the coordinates file that is exported by
\gridSVG{}. It is exported in the form of a \JS{} statement that
assigns an object literal to a variable, \code{"gridSVGCoords"}.

<<coordsJSON, results=verbatim, echo=FALSE>>=
jsondata <- readLines("pointsPlot.svg.coords.js")
jsondata <- paste0(jsondata, collapse = "\n")
cat(jsondata, "\n")
@

This shows all of the information available to \gridSVG{}, which
includes the viewport location and dimensions in terms of \SVG{}
pixels. Also included are the axis scales and how many pixels
\gridSVG{} thought an inch was as it was writing out the \SVG{} file.

\section*{Browser-based Modification}

We can modify the plot using the information described earlier by
executing \JS{} code to insert \SVG{} elements representing points
into the plot. To start off we first load the image into the
browser. What this does is loads the \SVG{} image, and executes any
\JS{} code that is referenced or included by the image. By default
\gridSVG{} exports coordinate information to a \JS{} file, along with
a utility \JS{} file that contains functions useful for working with
\gridSVG{} graphics. In particular, the utility code includes
functions that enable us to do unit conversion in the browser,
e.g. from \code{native} to \code{npc} or to \code{inches}.

Because \gridSVG{} must perform some name manipulation to ensure that
\SVG{} element \code{id}s are unique, a couple of \JS{} utility
functions require introduction. Firstly, although not stricly
necessary, if we know the name of the viewport, we can find out which
viewport path it belonged to by calling \code{grobViewport()}.

\begin{verbatim}
>>> grobViewport("datapoints");
"panelvp.1"
\end{verbatim}

We see that the viewport name is not exactly what we chose in \R{},
but suffixed with a numeric index. To drop the suffix, we can call
\code{baseViewportPath()} to get the original name of the viewport
path. This will be identical to the viewport name that we assigned in
R, or whatever \grid{} assigned it in the case that a name was
unspecified.

\begin{verbatim}
>>> baseViewportPath("panelvp.1");
"panelvp"
\end{verbatim}

Now that we can query the viewport name, we know which viewport to
draw into and the \SVG{} element that we can add elements to.
However, the issue remains that we really want to be able to use
\code{native} units in the browser, rather than \SVG{} pixels. To
remedy this, unit conversion functions have been created. These
functions are:

\begin{itemize}
\item \code{viewportConvertX}
\item \code{viewportConvertY}
\item \code{viewportConvertWidth}
\item \code{viewportConvertHeight}
\end{itemize}

The first two conversion functions take three parameters, the viewport
you want the location of, the size of the unit, and what type of unit
it is. These functions return a number which represents the location
in terms of \SVG{} pixels.

The second two conversion functions take an additional parameter which
is the type of unit that you want to convert to. This means we can
convert between \code{inches}, \code{native} and \code{npc} in the
browser without requiring an instance of \R{} available, so long as we
stick to our existing viewports.

As an example of how we might use these functions, we can find out
where the coordinates $(3, 14)$ are in the main panel by running the
following code:

\begin{verbatim}
>>> viewportConvertX("panelvp", 3, "native");
110.45
>>> viewportConvertY("panelvp", 14, "native");
283.1
\end{verbatim}

We now know that the location of $(3, 14)$ in \SVG{} pixels is
$(110.45, 283.1)$. Using this information we can insert a new point
into our plot at that location. To do this requires a bit of knowledge
of \JS{}, and knowledge of the \SVG{} DOM. To demonstrate this, a red
\SVG{} circle is going to be inserted at $(3, 14)$, in the plot using
\JS{}.

\begin{verbatim}
// Getting the element that contains all existing points
var panel = document.getElementById("panelvp.1");

// Creating an SVG circle element
var c = document.createElementNS("http://www.w3.org/2000/svg", "circle");

// Setting some SVG properties relating to the appearance
// of the circle
c.setAttribute("stroke", "rgb(255,0,0)");
c.setAttribute("fill", "rgb(255,0,0)");
c.setAttribute("fill-opacity", 1);
c.setAttribute("r", 4);

// Setting the location of our points via the gridSVG
// conversion functions
c.setAttribute("cx", viewportConvertX("panelvp", 3, "native"));
c.setAttribute("cy", viewportConvertY("panelvp", 14, "native"));

// Adding the point to the same "viewport" as the existing points
panel.appendChild(c);

\end{verbatim}

When running this code in the browser we see the new point. More
complex demonstrations and usage of \gridSVG{} utility functions are
possible, but are outside of the scope of this document. However, a
\JS{} library of particular significance that can assist greatly in
manipulating \SVG{} images in the browser is
\href{http://d3js.org/}{\textsf{d3.js}}.

All changes to an \SVG{} image via \JS{} are lost when the image is
reloaded. To modify the image programmatically while also saving the
state we need to use a tool other than \JS{}.

\section*{Modification via the \textsf{XML} package}

In order to reproduce the effect of the \JS{} example earlier, we will
be making use of the \textsf{XML} package in order to modify our
\SVG{} image. The first step is to load the required packages:

<<>>=
library(gridSVG)
library(XML)
@

We then need to parse the image, so that it is represented as a
document within \R{}.

<<parseSVG>>=
svgdoc <- xmlParse("pointsPlot.svg")
@

We know that the name of the viewport we are looking for has the
exported name of \code{"panelvp.1"}. An XPath query can be created to
collect this viewport.

<<vpGroup>>=
# Getting the object representing our viewport that contains
# our data points
panel <- getNodeSet(svgdoc,
                    "//svg:g[contains(@id, 'panelvp')]",
                    c(svg="http://www.w3.org/2000/svg"))[[1]]
@

Now, we need to read in the \JS{} file that contains the coordinates
information. However, some cleanup is needed because the code is
designed to be immediately loaded within a browser, and is thus not
simply \textsf{JSON}. We need to clean up the data so that it is able
to be parsed by \code{fromJSON}.

<<cleanJSON>>=
# Reading in, cleaning up and importing the coordinate system
jsonData <- readCoordsJS("pointsPlot.svg.coords.js")
@

We now have valid \textsf{JSON} in the form of a character
vector. Using this, we can initialise a coordinate system in \R{} by
utilising both \code{gridSVGCoords} and \code{fromJSON}.

<<initCoords>>=
gridSVGCoords(fromJSON(jsonData))
@

Now that a coordinate system is initialised we are able convert
coordinates into \SVG{} pixels. This means we can create a
\code{<circle>} element and correctly position it using
\code{"native"} units at $(3, 14)$.

<<createCircle>>=
# Creating an SVG circle element to insert into our image
# that is red, and at (3, 14)
circ <- newXMLNode("circle",
                   parent = panel,
                   attrs = list(cx = viewportConvertX("panelvp", 3, "native"),
                                cy = viewportConvertY("panelvp", 14, "native"),
                                r = 4,
                                stroke = "red",
                                fill = "red",
                                "fill-opacity" = 1))
@

Note that we have used the \code{viewportConvert*} functions to
position the circle at the correct locations. This is because the same
functions that are available in \JS{} are also available in \SVG{}.

This point has been inserted into the same \SVG{} group as the rest of
the points by setting the \code{"parent"} parameter to the object
representing the viewport group.

The only thing left to do is write out the new \textsf{XML} file with
the point added.

<<saveXML>>=
# Saving a new file for the modified image
saveXML(svgdoc, file = "newPointsPlot.svg")
@

The new \SVG{} image is located at \code{"newPointsPlot.svg"} and when
loaded into the browser shows the new point. The appearance of the
plot should be identical to the modifications we made using \JS{},
except these modifications are permanent and are able to be
distributed to others.

\end{document}

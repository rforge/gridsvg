\documentclass[a4paper]{article}
%\VignetteIndexEntry{coordinates}
\newcommand{\grid}{{\bf grid}}
\newcommand{\gridSVG}{{\sf gridSVG}}
\newcommand{\R}{{\sf R}}
\newcommand{\JS}{{\sf JavaScript}}
\newcommand{\SVG}{{\sf SVG}}
\newcommand{\code}[1]{{\tt #1}}
\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}

\usepackage{hyperref}

\SweaveOpts{keep.source=TRUE}

% Make it obvious we're dealing with R, not JS
<<echo = FALSE>>=
options(prompt = "R> ")
options(continue = "R+ ")
@

\title{Working with the gridSVG Coordinate System}
\author{Simon Potter}
\begin{document}

\maketitle

\section*{Introduction}

\grid{} is an alternative graphics system to the traditional base
graphics system provided by \R{}. Two key features of \grid{}
distinguish it from the base graphics system, graphics objects (grobs)
and viewports.

Viewports are how \grid{} defines a drawing context and plotting
region. All drawing occurs relative to the coordinate system within a
viewport. Viewports have a location and dimension and set scales on
the horizontal and vertical axes. Crucially, they also have a name so
we know how to refer to them.

Graphics objects store information necessary to describe how a
particular object is to be drawn. For example, a \grid{}
\code{circleGrob} contains the information used to describe a circle,
in particular its location and its radius. As with viewports, graphics
objects also have names.

The task that \gridSVG{} performs is to translate viewports and
graphics objects into \SVG{} equivalents. In particular, the exported
\SVG{} image retains the naming information on viewports and graphics
objects. The advantage of this is we can still refer to the same
information in \grid{} and in \SVG{}. In addition, we are able to
annotate \grid{} grobs to take advantage of \SVG{} features such as
hyperlinking and animation.

\section*{The \gridSVG{} Coordinate System}

When exporting \grid{} graphics as \SVG{}, instead of positioning
within a viewport, all drawing occurs within a single pixel-based
coordinate system. This document describes how \gridSVG{} exports
additional information during this process to retain the original.

To demonstrate this, we will show how to add points to an exported
plot, both from within \R{} and also, less permanently, within a \JS{}
and \SVG{} capable web browser.

Firstly, consider the following code which is a simple plot containing
two items of interest. Firstly, a viewport is created which has scales
defined for each of its axes. Secondly, points are added to the plot
using native units. We then write this out to \SVG{} in a file called
\code{"pointsPlot.svg"} which can be viewed in a web browser.

<<>>=
library(gridSVG)
@

<<pointsPlot, fig=TRUE, include=FALSE>>=
panelvp <- plotViewport(xscale = c(0, 20),
                        yscale = c(0, 20),
                        name = "panelvp")
pushViewport(panelvp)
grid.xaxis()
grid.yaxis()
grid.points(x = runif(10, 5, 15),
            y = runif(10, 5, 15),
            pch = 16,
            name = "datapoints")
popViewport()

gridToSVG("pointsPlot.svg")
@

The challenge is to now modify this plot so that we can add extra
information, such as new data points. As the \SVG{} file was exported,
all of the locations on the plot were transformed into pixels. This
means that in our \SVG{} file, none of the axis scales exist, and the
locations of points are no longer native coordinates, but absolutely
positioned pixels.


<<showPointsGrob, echo = FALSE>>=
svgdoc <- xmlParse("pointsPlot.svg")
pointsGroup <- getNodeSet(svgdoc,
                          "//svg:g[@id='datapoints']",
                          c(svg="http://www.w3.org/2000/svg"))[[1]]
cat(saveXML(pointsGroup))
@

The previous \SVG{} fragment shows what \gridSVG{} has translated the
points to. Note that the locations (\code{x} and \code{y}) and
dimensions (\code{width} and \code{height}) of each of the points have
been translated into absolute locations in \SVG{}. They no longer
relate to the axis scales in their viewport, instead they are \SVG{}
pixels.

Recent changes in \gridSVG{} have enabled us to keep viewport
information by exporting viewport metadata in the form of
\textsf{JSON}, a structured data format. This enables us to be able
to retain viewport locations and scales so that we can now transform
pixel locations to native coordinates, and vice versa.

The following fragment shows the coordinates file that is exported by
\gridSVG{}. It is exported in the form of a \JS{} statement that
assigns an object literal to a variable, \code{"gridSVGCoords"}.

<<coordsJSON, results=verbatim, echo=FALSE>>=
jsondata <- readLines("pointsPlot.svg.coords.js")
jsondata <- paste0(jsondata, collapse = "\n")
cat(jsondata, "\n")
@

This shows all of the information available to \gridSVG{}. This \JS{}
object contains a list of viewport names, with each viewport name
associated with its metadata. This metadata includes the viewport
location and dimensions in terms of \SVG{} pixels. Also included are
the axis scales, along with the resolution that the viewport was
exported at. The resolution simply represents the number of pixels
that span an inch.

\section*{Browser-based Modification}

We can modify the plot using the information described earlier by
executing \JS{} code to insert \SVG{} elements representing points
into the plot. To start off we first load the image into the
browser. What this does is loads the \SVG{} image, and executes any
\JS{} code that is referenced or included by the image. By default
\gridSVG{} exports coordinate information to a \JS{} file, along with
a utility \JS{} file that contains functions useful for working with
\gridSVG{} graphics. In particular, the utility code includes
functions that enable us to do unit conversion in the browser,
e.g. from \code{native} to \code{npc} or to \code{inches}.

Because \gridSVG{} must perform some name manipulation to ensure that
\SVG{} element \code{id}s are unique, a couple of \JS{} utility
functions require introduction. Firstly, although not stricly
necessary, if we know the name of the viewport, we can find out which
viewport path it belonged to by calling \code{grobViewport()}.

\begin{verbatim}
JS> grobViewport("datapoints");
"panelvp.1"
\end{verbatim}

We see that the viewport name is not exactly what we chose in \R{},
but suffixed with a numeric index. To drop the suffix, we can call
\code{baseViewportPath()} to get the original name of the viewport
path. This will be identical to the viewport name that we assigned in
R, or whatever \grid{} assigned it in the case that a name was
unspecified.

\begin{verbatim}
JS> baseViewportPath("panelvp.1");
"panelvp"
\end{verbatim}

Now that we can query the viewport name, we know which viewport to
draw into and the \SVG{} element that we can add elements to.
However, the issue remains that we really want to be able to use
\code{native} units in the browser, rather than \SVG{} pixels. To
remedy this, unit conversion functions have been created. These
functions are:

\begin{itemize}
\item \code{viewportConvertX}
\item \code{viewportConvertY}
\item \code{viewportConvertWidth}
\item \code{viewportConvertHeight}
\end{itemize}

The first two conversion functions take three parameters, the viewport
you want the location of, the size of the unit, and what type of unit
it is. These functions return a number which represents the location
in terms of \SVG{} pixels.

The second two conversion functions take an additional parameter which
is the type of unit that you want to convert to. This means we can
convert between \code{inches}, \code{native} and \code{npc} in the
browser without requiring an instance of \R{} available, so long as we
stick to our existing viewports.

As an example of how we might use these functions, we can find out
where the coordinates $(3, 14)$ are in the main panel by running the
following code:

\begin{verbatim}
JS> viewportConvertX("panelvp", 3, "native");
110.45
JS> viewportConvertY("panelvp", 14, "native");
283.1
\end{verbatim}

We now know that the location of $(3, 14)$ in \SVG{} pixels is
$(110.45, 283.1)$. Using this information we can insert a new point
into our plot at that location. To do this requires a bit of knowledge
of \JS{}, and knowledge of the \SVG{} DOM. To demonstrate this, a red
\SVG{} circle is going to be inserted at $(3, 14)$, in the plot using
\JS{}.

\begin{verbatim}
// Getting the element that contains all existing points
var panel = document.getElementById("panelvp.1");

// Creating an SVG circle element
var c = document.createElementNS("http://www.w3.org/2000/svg", "circle");

// Setting some SVG properties relating to the appearance
// of the circle
c.setAttribute("stroke", "rgb(255,0,0)");
c.setAttribute("fill", "rgb(255,0,0)");
c.setAttribute("fill-opacity", 1);
c.setAttribute("r", 4);

// Setting the location of our points via the gridSVG
// conversion functions
c.setAttribute("cx", viewportConvertX("panelvp", 3, "native"));
c.setAttribute("cy", viewportConvertY("panelvp", 14, "native"));

// Adding the point to the same "viewport" as the existing points
panel.appendChild(c);

\end{verbatim}

When running this code in the browser we see the new point. More
complex demonstrations and usage of \gridSVG{} utility functions are
possible, and will be demonstrated in \textbf{Section XXXXXX}. A \JS{}
library of particular significance that can assist greatly in
manipulating \SVG{} images in the browser is
\href{http://d3js.org/}{\textsf{d3.js}}. \textsf{d3.js} will feature
prominently in our more complex example.

All changes to an \SVG{} image via \JS{} are lost when the image is
reloaded. To modify the image programmatically while also saving the
state we need to use a tool other than \JS{}.

\section*{Modification via the \textsf{XML} package}

In order to reproduce the effect of the \JS{} example earlier, we will
be making use of the \textsf{XML} package in order to modify our
\SVG{} image. As \gridSVG{} automatically loads the \textsf{XML}
package, all of the functionality from the \textsf{XML} package is
readily available to us.

We first need to parse the image, so that it is represented as a
document within \R{}.

<<parseSVG>>=
svgdoc <- xmlParse("pointsPlot.svg")
@

We know that the name of the viewport we are looking for has the
exported name of \code{"panelvp.1"}. An XPath query can be created to
collect this viewport.

<<vpGroup>>=
# Getting the object representing our viewport that contains
# our data points
panel <- getNodeSet(svgdoc,
                    "//svg:g[contains(@id, 'panelvp')]",
                    c(svg="http://www.w3.org/2000/svg"))[[1]]
@

Now, we need to read in the \JS{} file that contains the coordinates
information. However, some cleanup is needed because the code is
designed to be immediately loaded within a browser, and is thus not
simply \textsf{JSON}. We need to clean up the data so that it is able
to be parsed by \code{fromJSON}.

<<cleanJSON>>=
# Reading in, cleaning up and importing the coordinate system
jsonData <- readCoordsJS("pointsPlot.svg.coords.js")
@

We now have valid \textsf{JSON} in the form of a character
vector. Using this, we can initialise a coordinate system in \R{} by
utilising both \code{gridSVGCoords} and \code{fromJSON}.

<<initCoords>>=
gridSVGCoords(fromJSON(jsonData))
@

Now that a coordinate system is initialised we are able convert
coordinates into \SVG{} pixels. This means we can create a
\code{<circle>} element and correctly position it using
\code{"native"} units at $(3, 14)$.

<<createCircle>>=
# Creating an SVG circle element to insert into our image
# that is red, and at (3, 14)
circ <- newXMLNode("circle",
                   parent = panel,
                   attrs = list(cx = viewportConvertX("panelvp", 3, "native"),
                                cy = viewportConvertY("panelvp", 14, "native"),
                                r = 4,
                                stroke = "red",
                                fill = "red",
                                "fill-opacity" = 1))
@

Note that we have used the \code{viewportConvert*} functions to
position the circle at the correct locations. This is because the same
functions that are available in \JS{} are also available in \SVG{}.

This point has been inserted into the same \SVG{} group as the rest of
the points by setting the \code{"parent"} parameter to the object
representing the viewport group.

The only thing left to do is write out the new \textsf{XML} file with
the point added.

<<saveXML, results = hide>>=
# Saving a new file for the modified image
saveXML(svgdoc, file = "newPointsPlot.svg")
@

The new \SVG{} image is located at \code{"newPointsPlot.svg"} and when
loaded into the browser shows the new point. The appearance of the
plot should be identical to the modifications we made using \JS{},
except these modifications are permanent and are able to be
distributed to others.

An advantage of being able to modify the image, or even to generate
the image immediately is that it opens up the possibility of serving
dynamic \SVG{} images over the web. Such an example is demonstrated in
\textbf{Section XXXXX} using the \textsf{Rook} package.

\end{document}
